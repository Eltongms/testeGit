https://stackoverflow.com/questions/65434544/whats-the-difference-between-git-rm-cached-git-restore-staged-and-gi

TERMOS COMUMS

STAGE AREA == INDEX == CACHE
HEAD == COMMIT ATUAL



ADICIONADO E EXCLUINDO ARQUIVOS



git add file.js  # work directory -> stage   seja novo/atualização/deleção  em work directory

git rm --cached file.js #  stage -> null     somente remove do stage, implica em ausencia deste arquivo no próximo commit caso ele não exista no HEAD


- STAGE AREA

git add file.js # adiciona arquivo ao stage
git restore --stage file.js # copia para o stage a versão que está no HEAD, independente do que está no diretório.
git rm --cached file.js # remove do stage e mantém no diretório

- REPOSITÓRIO

git rm file.js #apaga do sistema de arquivo e registra a deleção no stage
git add <arquivo deletado pelo usário> # registra a deleação no stage

caso tenha apagado pelo sistema de arquivos, o git status acusará DELETED EM VERMELHO. 
para registar no git a deleção (por no stage a deleção) use git add ou git rm

git add file.js # após deleção pele sistema de arquivo


- DIRETÓRIO DE TRABALHO

git rm -f file.js # apaga do stage e do diretório de tabalho









HEAD é um apontamento para o nódulo atualmente ativo (arquivos em que está trabalhando).

O estado normal do git é 

MOVENDO PELOS NODOS

HEAD -> main -> C2. 
Mas é possível soltar a cabeça (detached) com 

git checkout C2
ficando HEAD -> C2  e main -> C2

Para prender a cabeça basta dar um checkout em um dos branch
git checkout main

Mudando o branch(ponteiro) para outro nodo
git branch -f main a584s

REFERÊNCIAS RELATIVAS

git checkout main^    volta um nível
git checkout main^^   volta dois nível

git checkout HEAD^   volta o head uma vez


git checktou main~3  volta o main 3 nodos









REVERTENDO MUDANÇAS

quando local pode ser usado 
git reset HEAD~1

quando remoto 
git revert HEAD


para criar um branch usa-se
git checkout -b nomebranch

a partir do git 2.23 pode usar o comando
git switch nomebranch   para tracar
git switch -c nomebranch para criar.  


EXIBIR 

git log --oneline (faz cada comiit ocupa uma linha) --all (exibe de todos os branch) --decorate (informa em qual branch está cada commit) --graph (faz um grafico)
git branch -v (mostra os branch existentes e, onde estáo HEAD e os descritivos)
git branch --merged
git branch --no-merged


Descritivos 
(main) é local
(origin/main) é local onde o push foi atualizado pela ultima vez
CHECKANDO CONFIGURAÇÃO 

# para usar ssh o endereço precisa estar dessa forma
git remote  -v
origin	git@github.com:Eltongms/testeGit.git (fetch)
origin	git@github.com:Eltongms/testeGit.git (push)

# caso não esteja é preciso corrigier usando:
git remote set-url --add origin git@github.com:Eltongms/testeGit.git


git remote show # mostra os repositórios remotos configurados
git remot show origin # mostra os detalhes de um repositório.



CLONANDO

git clone https://github.com/Eltongms/testeGit.git

- Acessando branch remoto

git branch -a
git checkout -b nomebranch origin/nomebranch   # vai criar uma branch local baseado no branch remoto


ENVIANDO DE VOLTA

 
 git push # enviará apenas o branch atual
 git push origin reattach # enviará um branch especifico



GIT MERGE

m1 -> m2 -> m3(main*) 
b1 -> b2(bugFix)

git merge bugFix

m1 -> m2 -> m3 -> m3b2(main*)
b1 -> b2(bugFix)

git checkout bugFix; git merge main;

m1 -> m2 -> m3 -> mb4(main*)(bugFix)
b1 -> b2
 

# Cria um novo nódulo que mescla main a bugFix, possuindo ambos branch como ancestrais, o branch selecionado continua sendo main que passa a pontar para o novo nódulo, o branch bugFix permanece parado onde estava. 
# Se for necessário corrigir basta selecionar bugFix e fazer merge com main, isto fará ambos branch aponterem para o novo nódulo.


GIT REBASE

m1 -> m2 -> m3(main) 
b1 -> b2(bugFix*)

git rebase main (main é o destino para onde vão os comits)

m1 -> m2 -> m3(main) -> b1 -> b2(bugFix*) 


# pega o branch bugFix e o coloca a frente do main, esse branch atual deixa de existir, passando a ser um nódulo a frente 
# para fazer o main retomar a ponto do ramo faça :

git checkout main 
git rebase bugfix

m1 -> m2 -> m3(main) -> b1 -> b2(bugFix) -> m3b2(main*)






